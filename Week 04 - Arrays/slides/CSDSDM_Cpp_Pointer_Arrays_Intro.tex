% !TeX TS-program = xelatex
\documentclass[aspectratio=169, 12pt]{beamer}
\usefonttheme{professionalfonts}
\usefonttheme{serif}
\usepackage[T1]{fontenc}
\usepackage{fontspec-xetex}

\usepackage{booktabs}
\usepackage{listings}
\usepackage{subcaption}
\setmainfont{Lato}

% Local configuration
\renewcommand{\figurename}{}
\DeclareCaptionFormat{custom}
{%
	\tiny #3
}
\captionsetup{format=custom}

% Title stuff
\title{Computer Systems, et al.}
\date{Week 04}
\author{Vassilis Markos, Mediterranean College}

\usetheme{streamline}

% Local Commands
\newcommand{\ohref}[1]{\href{#1}{\texttt{#1}}}

% Code listings

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\begin{document}

	\begin{frame}
		\titlepage
	\end{frame}

	\begin{frame}{Contents}
		\tableofcontents
	\end{frame}

%	\section{A Brief Intro}\label{sec:a-brief-intro}
%	
%	\sectionframe
%	
%	\begin{headsup}{Desperate Times, Desperate Measures}
%		\begin{minipage}[t]{0.40\textwidth}
%			\vspace{0pt}
%			Since we are transitioning on a new platform, things are still a bit quirky. So, to make sure we keep track of who is here and who is not, please \textbf{scan the QR code shown next} or \textbf{click the link below it} and fill in this form with your information (confidential).
%		\end{minipage}\hfill
%		\begin{minipage}[t]{0.58\textwidth}
%			\vspace{0pt}
%			\raggedleft
%			\includegraphics[scale=0.35]{../../assets/attendance_form.png}
%			\centering
%			\ohref{https://forms.gle/ng5fvdhjZFt5Rs128}
%		\end{minipage}
%	\end{headsup}
%
%	\begin{headsup}{Desperate Times, Desperate Measures}
%		\begin{minipage}[t]{0.50\textwidth}
%			\vspace{0pt}
%			For similar reasons, we will also be using a public shared drive folder to keep our materials as long as our platform is a bit unstable. To visit the platform and download this lecture's materials please use the QR shown right or the link below.
%		\end{minipage}\hfill
%		\begin{minipage}[t]{0.48\textwidth}
%			\vspace{0pt}
%			\raggedleft
%			\includegraphics[scale=0.25]{../../assets/shared_folder.png}
%			\centering
%		\end{minipage}
%		\vfill
%		\begin{scriptsize}
%			\ohref{https://drive.google.com/drive/folders/1l94DqkDkFUmLSHZ40KGb8qYMbgM5EnmW?usp=sharing}
%		\end{scriptsize}
%	\end{headsup}
	
	\section{Pointers}\label{sec:pointers}
	
	\sectionframe

	\begin{frame}{Can You Predict The Output?}
		\lstinputlisting[language=C++]{../source/stars_005.cpp}
	\end{frame}

	\begin{frame}{Variations On A Theme: What Will This Print?}
		\scalebox{0.9}{%
		\lstinputlisting[language=C++]{../source/stars_005a.cpp}}
	\end{frame}

	\begin{frame}[fragile]{A Typical Output}
		For user input \texttt{7} the above program might print:
		\begin{verbatim}
Enter an int: 7
7
7
22002
\end{verbatim}
	Can you explain why?
	\end{frame}

	\begin{frame}{Pointer Arithmetic}
		\begin{itemize}
			\item Since the user has entered \texttt{7}, the value of \texttt{x} is \texttt{7}, so this is the first of the two sevens.
			\item The second seven is the value stored at \texttt{y} through the evaluation of the expression \texttt{(*ptrx++)}:
			\begin{itemize}
				\item \texttt{*ptrx++} first uses the current value of \texttt{ptrx}, which is where \texttt{x} is stored in RAM and then increments \texttt{ptrx} by ``1''.
				\item Since \texttt{ptrx} is a pointer to an \texttt{int}, ``increment  by 1'' in this case is interpreted as ``increment by \textbf{4 bytes}'', i.e., the size of an \texttt{int}.
				\item So, in this case, \texttt{y} contains the value of \texttt{x}, which is what \texttt{ptrx} points to.
			\end{itemize}
		\end{itemize}
	\end{frame}
	
	\begin{frame}{Pointer Arithmetic}
		\begin{itemize}
			\item The value of \texttt{z} is determined through the expression \texttt{*++ptrx}.
			\item This means that:
			\begin{itemize}
				\item \texttt{++ptrx} \textbf{first increments} the pointer by 4 bytes and then;
				\item \textbf{dereferences} the incremented value.
				\item So, C++ is now trying to interpret what is stored in the corresponding memory locations, which results, in our case, to \texttt{22002}.
				\item Note that what is kept in those locations is not something we can predict, as now \texttt{ptrx} points to a memory location that we have not assigned ourselves a value. So, each time you execute this program, something different should be printed on your console.
			\end{itemize}
		\end{itemize}
	\end{frame}

	\begin{headsup}{A Brief Note About \texttt{auto}}
		In the above, we declared \texttt{z} as \texttt{auto}:
		\begin{itemize}
			\item \texttt{auto} is originally a C thing but there it was virtually useless, as discussed in the C Infrequently Asked Questions (IAQ: \ohref{https://www.seebs.net/faqs/c-iaq.html}).
			\item Since C++~11 it is actually useful when it comes to declaring a complex variable type which can, however, be inferred by the compiler at compilation time.
			\item One common usage example is with C++ Templates, which, however, will not bother us (Phew!).
		\end{itemize}
	\end{headsup}

	\begin{frame}{Playing Around a Bit}
		We can be more specific and avoid using \texttt{auto}, as shown below:
		\scalebox{0.85}{%
		\lstinputlisting[language=C++]{../source/stars_005b.cpp}}
	\end{frame}

	\begin{frame}[fragile]{Playing Around a Bit}
		A typical output should be something like this:
		\begin{verbatim}
Enter an int: 7
ptrx: 0x7ffe50cc8188
7
21967
ptrx: 0x7ffe50cc818c
\end{verbatim}
	Here, \texttt{y} is declared as an \texttt{int}, so C++ prints an \texttt{int} as read from the 4 bytes stored at memory locations: \texttt{0x7ffe50cc818c}, \texttt{0x7ffe50cc818d}, \texttt{0x7ffe50cc818e}, \texttt{0x7ffe50cc818f}.
	\end{frame}

	\begin{frame}{More Quirks}
		\begin{itemize}
			\item In \texttt{source/stars\_005b.cpp} change in line 12 the type declaration of \texttt{y} from \texttt{int} to \texttt{double}.
			\item What do you observe when you run the program?
			\item Now, a typical value of \texttt{y} looks somewhat like: \texttt{-5.48475e+07}.
			\item Can you explain this behaviour?\pause
			\item In short, this is because declaring different data types forces C++ to interpret the content at the referenced memory locations in different ways (in principle).
		\end{itemize}
	\end{frame}

	\begin{headsup}{Computer Numbers}
		\begin{minipage}[t]{0.5\textwidth}%
			\vspace{0pt}%
			\begin{itemize}
				\item Assume that a computer's memory looks as shown right (memory locations indicated at the bottom of each cell).
				\item Then, which bytes should the compiler use to read an \texttt{int} starting at memory location \texttt{0x7ffefcbb17f4}?
			\end{itemize}
		\end{minipage}\hfill
		\begin{minipage}[t]{0.46\textwidth}%
			\vspace{0pt}%
			\begin{center}
				\begin{tabular}{|c|c|}%
					\hline%
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}01110110}\\{\tiny 0x7ffefcbb17f4}%
						\end{tabular}} & 
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}11111111}\\{\tiny 0x7ffefcbb17f5}%
					\end{tabular}}\\\hline
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}01111001}\\{\tiny 0x7ffefcbb17f6}%
					\end{tabular}} &
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}10101010}\\{\tiny 0x7ffefcbb17f7}%
					\end{tabular}}\\\hline
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}01111001}\\{\tiny 0x7ffefcbb17f8}%
					\end{tabular}} & 
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}00011110}\\{\tiny 0x7ffefcbb17f9}%
					\end{tabular}}\\\hline
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}10101001}\\{\tiny 0x7ffefcbb17fa}%
					\end{tabular}} &
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}00000001}\\{\tiny 0x7ffefcbb17fb}%
					\end{tabular}}\\\hline
				\end{tabular}
			\end{center}
		\end{minipage}
	\end{headsup}

	\begin{headsup}{Computer Numbers}
		\begin{minipage}[t]{0.5\textwidth}%
			\vspace{0pt}%
			\begin{itemize}
				\item Since an \texttt{int} takes up 4 bytes in the computer's memory, the compiler will make use of the first four bytes, as shown right. This results to the integer value: \texttt{1996454314}.
				\item What if we want to read a double?
			\end{itemize}
		\end{minipage}\hfill
		\begin{minipage}[t]{0.46\textwidth}%
			\vspace{0pt}%
			\begin{center}
				\begin{tabular}{|c|c|}%
					\hline%
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}01110110}\\{\tiny 0x7ffefcbb17f4}%
					\end{tabular}} & 
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}11111111}\\{\tiny 0x7ffefcbb17f5}%
					\end{tabular}}\\\hline
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}01111001}\\{\tiny 0x7ffefcbb17f6}%
					\end{tabular}} &
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}10101010}\\{\tiny 0x7ffefcbb17f7}%
					\end{tabular}}\\\hline
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}01111001}\\{\tiny 0x7ffefcbb17f8}%
					\end{tabular}} & 
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}00011110}\\{\tiny 0x7ffefcbb17f9}%
					\end{tabular}}\\\hline
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}10101001}\\{\tiny 0x7ffefcbb17fa}%
					\end{tabular}} &
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlinetextgray}00000001}\\{\tiny 0x7ffefcbb17fb}%
					\end{tabular}}\\\hline
				\end{tabular}
			\end{center}
		\end{minipage}
	\end{headsup}

	\begin{headsup}{Computer Numbers}
		\begin{minipage}[t]{0.5\textwidth}%
			\vspace{0pt}%
			\begin{itemize}
				\item Since a \texttt{double} takes up 8 bytes in the computer's memory, the compiler will make use of all the bytes, as shown right. This results to the float value: \texttt{1.5857893356345228e+265}.
				\item For more on how bitstrings are converted to numbers:
				\begin{itemize}
					\item \href{https://en.wikipedia.org/wiki/Two\%27s_complement}{\texttt{Two's Complement}}.
					\item \href{https://en.wikipedia.org/wiki/IEEE_754}{IEEE 754}.
				\end{itemize}
			\end{itemize}
		\end{minipage}\hfill
		\begin{minipage}[t]{0.46\textwidth}%
			\vspace{0pt}%
			\begin{center}
				\begin{tabular}{|c|c|}%
					\hline%
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}01110110}\\{\tiny 0x7ffefcbb17f4}%
					\end{tabular}} & 
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}11111111}\\{\tiny 0x7ffefcbb17f5}%
					\end{tabular}}\\\hline
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}01111001}\\{\tiny 0x7ffefcbb17f6}%
					\end{tabular}} &
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}10101010}\\{\tiny 0x7ffefcbb17f7}%
					\end{tabular}}\\\hline
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}01111001}\\{\tiny 0x7ffefcbb17f8}%
					\end{tabular}} & 
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}00011110}\\{\tiny 0x7ffefcbb17f9}%
					\end{tabular}}\\\hline
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}10101001}\\{\tiny 0x7ffefcbb17fa}%
					\end{tabular}} &
					{\scriptsize\ttfamily\begin{tabular}{c}%
							{\color{streamlineorange}00000001}\\{\tiny 0x7ffefcbb17fb}%
					\end{tabular}}\\\hline
				\end{tabular}
			\end{center}
		\end{minipage}
	\end{headsup}

	\begin{frame}{Can You Predict The Output?}
		\scalebox{0.85}{%
		\lstinputlisting[language=C++]{../source/stars_006.cpp}}
	\end{frame}

	\begin{frame}{Can You Predict The Output?}
		\lstinputlisting[language=C++]{../source/stars_007.cpp}
	\end{frame}

	\section{Arrays}\label{sec:arrays}
	
	\sectionframe
	
	\begin{frame}{Arrays In C++}
		Can you guess what the following will print?
		\scalebox{0.95}{%
		\lstinputlisting[language=C++]{../source/arrays_001.cpp}}
	\end{frame}
	
	\begin{frame}{Array Initialisation}
		We can also provide array elements all at once, as follows:
		\lstinputlisting[language=C++]{../source/arrays_002.cpp}
	\end{frame}
	
	\begin{frame}{Dynamic Initialisation}
		We can also initialise the values of an array based on others' input (e.g., users, another process):
		\scalebox{0.95}{%
		\lstinputlisting[language=C++]{../source/arrays_003.cpp}}
	\end{frame}
	
	\begin{frame}{What Will This Print?}
		\lstinputlisting[language=C++]{../source/arrays_004.cpp}
	\end{frame}
	
	\begin{frame}[fragile]{Dynamic Initialisation And Array Size}
		The above must have printed something along the following lines:
		\begin{verbatim}
arrays_004.cpp: In function ‘int main()’:
arrays_004.cpp:6:10: error: storage size of ‘arr’
isn’t known
6 |     char arr[];
  |          ^~~
\end{verbatim}
		This actually means that in order to \textbf{refer to an array's element by its index} you must \textbf{first determine the array's size!}
	\end{frame}

	\begin{frame}{Pointers And Arrays}
		What will the following print?
		\lstinputlisting[language=C++]{../source/arrays_005.cpp}
	\end{frame}

	\begin{headsup}{Pointers And Arrays}
		Do you observe something strange in the following?
		\lstinputlisting[language=C++, linerange={5-10}]{../source/arrays_005.cpp}\pause
		\begin{itemize}
			\item \textbf{Line 3:} We declare an integer pointer and store the \textbf{array} there, \textbf{not a reference!}\pause
			\item Why does it work?
		\end{itemize}
	\end{headsup}

	\begin{headsup}{Pointers And Arrays}
		\begin{itemize}
			\item In C++, arrays of type \texttt{<T>} are actually pointers to items of type \texttt{<T>}.
			\item This means that, when declaring an array, we are actually declaring a pointer to the first memory location occupied by its first element.
			\item So, arrays are actually of \textbf{pointer type!}
			\item This means that using \texttt{\&} to get their memory address is of no use, since they already represent a memory address.
		\end{itemize}
	\end{headsup}
	
	\begin{frame}{Pointer Tricks}
		What will the following print?
		\lstinputlisting[language=C++]{../source/arrays_006.cpp}
	\end{frame}

	\begin{frame}{Pointer Tricks}
		What will the following print?
		\lstinputlisting[language=C++]{../source/arrays_007.cpp}
	\end{frame}

	\begin{frame}{Pointer Tricks}
		What will the following print?
		\lstinputlisting[language=C++]{../source/arrays_008.cpp}
	\end{frame}
	
	\begin{frame}{Looping Over An Array}
		\lstinputlisting[language=C++]{../source/arrays_009.cpp}
	\end{frame}
	
	\begin{frame}{Looping Over An Array With Pointers}
		Can you loop over the same array without using the \texttt{arr[i]} syntax?\pause
		\lstinputlisting[language=C++]{../source/arrays_010.cpp}
	\end{frame}
	
	\begin{frame}{Pointer Arithmetic (Again)}
		\begin{itemize}
			\item In general, the expression \texttt{pointer + integer} is interpreted as: increment the \texttt{pointer} by the size of its pointing type times the \texttt{integer}.
			\item So, for an \texttt{int* ptr}, \texttt{ptr + 6} should be interpreted as ``move the pointer \texttt{ptr} by \texttt{6 * sizeof(int)}, i.e., \texttt{6 * 4} bytes''.
			\item So, for a \texttt{double* ptr}, \texttt{ptr + 5} should be interpreted as ``move the pointer \texttt{ptr} by \texttt{5 * sizeof(double)}, i.e., \texttt{5 * 8} bytes''.
		\end{itemize}
	\end{frame}

	\begin{frame}{Passing Arrays To Functions}
		What will this print?
		\scalebox{0.90}{%
		\lstinputlisting[language=C++]{../source/arrays_011.cpp}}
	\end{frame}

	\begin{frame}{Passing Arrays To Functions}
		What will this print?
		\scalebox{0.90}{%
		\lstinputlisting[language=C++]{../source/arrays_012.cpp}}
	\end{frame}

	\begin{frame}{Passing Arrays To Functions}
		What will this print?
		
		\scalebox{0.71}{%
		\lstinputlisting[language=C++]{../source/arrays_013.cpp}}
	\end{frame}

	\begin{headsup}{Array Decay}
		\begin{itemize}
			\item A common C++ catch--phrase is that ``arrays decay into pointers''.
			\item This simply means that, whenever required, arrays are interpreted as pointers, as we have already discussed above.
			\item As a consequence, when passing an array to a function, we are actually passing a pointer.
			\item This means that an array is always \textbf{passed by reference}. So, in case we need to pass an array be value, we have to devise various tricks we shall see in upcoming lectures.
		\end{itemize}
	\end{headsup}
	
%	\begin{frame}{2D Arrays}
%		
%	\end{frame}

%	\section{Arrays \& Strings}\label{sec:arrays----strings}
%	
%	\sectionframe
	
%	\section{Strings}\label{sec:strings}
%	
%	\sectionframe
%	
%	\begin{frame}{Quirky Strings}
%		\begin{figure}
%			\centering
%			\includegraphics[scale=0.42]{./assets/rtl.png}
%			\caption{Beware! This is actually used in malicious ways! Source: \ohref{https://xkcd.com/1137/}.}
%		\end{figure}
%	\end{frame}
	
	\section{Fun Time! (Optional)}\label{sec:fun-time}
	
	\sectionframe
	
	\begin{frame}{Advanced Pointer Fun}
		While we have said enough about pointers, we have not explored pointer--land in full. The following tutorial will help you do so:
		\begin{center}
			\ohref{https://learnmoderncpp.com/arrays-pointers-and-loops/}
		\end{center}
		Follow the tutorial step--by--step and pay attention to the ``Experiments'' it asks you to execute. Write down your observations in a document, which you will share with me at the end of the class at: \texttt{v.markos@mc-class.gr}.
	\end{frame}
	
	\begin{frame}{Strings}
		Also, as a preparation for our next lecture -- and an extension of the concepts we have explored in this lecture -- follow the tutorial shown below:
		\begin{center}
			\ohref{https://learnmoderncpp.com/string-and-character-literals/}
		\end{center}
		Again, pay attention to the detailed examples, making sure you understand what is going on there!
	\end{frame}
	
	\begin{frame}{Homework}%
		Complete all exercises and problems in MIT's C++ course second assignment, found here:
		\begin{center}%
			\vspace{-1.0\topsep}%
			\small%
			\href{https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-2011/797ebff419fa2cc3a10af2c5f19be961_MIT6_096IAP11_assn02.pdf}{\texttt{https://ocw.mit.edu/courses/6-096-introduction-to-c-january-iap-\\2011/797ebff419fa2cc3a10af2c5f19be961\_MIT6\_096IAP11\_assn02.pdf}}%
		\end{center}
		For your convenience, you can also find the assignment file in this lecture's materials, at: \ohref{../homework/MIT6-096IAP11-assn02.pdf}.
		Submit all your work in the online form below as a single \texttt{.zip} file:
		\begin{center}
			\ohref{https://forms.gle/rSq3VSpcouRAVjqMA}
		\end{center}
		or via email at: \texttt{v.markos@mc-class.gr}.
	\end{frame}

	\begin{frame}{Any Questions?}
		\begin{minipage}{0.35\textwidth}
			\raggedright
			Do not forget to fill in the questionnaire shown right!
		\end{minipage}\hfill
		\begin{minipage}{0.58\textwidth}
			\vspace{0pt}
			\raggedleft
			\includegraphics[scale=0.4]{../../assets/post_lesson_assessment.png}
			\centering
			\ohref{https://forms.gle/dKSrmE1VRVWqxBGZA}
		\end{minipage}
	\end{frame}
	
\end{document}